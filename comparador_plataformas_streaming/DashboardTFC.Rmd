---
title: "Dashboard"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
runtime: shiny
---

```{r,echo=FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  echo=FALSE
)
```

```{r, echo = FALSE,message = FALSE,warning = FALSE}
if (!require(shiny)) install.packages('shiny') 
library(shiny) 
if (!require(flexdashboard)) install.packages('flexdashboard') 
library(flexdashboard)
library(RColorBrewer)
if (!require(plotly)) install.packages('plotly') 
library(plotly)
if (!require(urca)) install.packages('urca') 
library(urca)
if (!require(GGally)) install.packages('GGally') 
library(GGally)
if (!require(pxR)) install.packages('pxR') 
library(pxR)
if (!require(fpp3)) install.packages('fpp3') 
library(fpp3)
if (!require(tidyverse)) install.packages('tidyverse') 
library(tidyverse)
if (!require(wordcloud)) install.packages('wordcloud') 
library(wordcloud)
if (!require(openxlsx)) install.packages('openxlsx') 
library(openxlsx)
if (!require(patchwork)) install.packages('patchwork') 
library(patchwork)
if (!require(ggplot2)) install.packages('ggplot2') 
library(ggplot2)
if (!require(highcharter)) install.packages('highcharter') 
library(highcharter)
if (!require(leaflet)) install.packages('leaflet') 
library(leaflet)
if (!require(geojsonio)) install.packages('geojsonio') 
library(geojsonio) 
library(shinydashboard)
if (!require(DT)) install.packages('DT') 
library(DT)

```



```{r}
netflix <- read.csv("datos/netflix.csv")
hbo <- read.csv("datos/hbo.csv")
amazon <- read.csv("datos/amazon.csv")

netflix$platform = "Netflix"
hbo$platform = "HBO"
amazon$platform = "Amazon Prime"

all_platforms <- rbind(netflix, hbo, amazon)
all_movies <- subset(all_platforms, type == "MOVIE")
all_shows <- subset(all_platforms, type == "SHOW")

comedy_movies_series <- all_platforms[grepl("comedy", all_platforms$genres, ignore.case = TRUE), ]
comedy_movies <- comedy_movies_series %>%
  filter(type == "MOVIE")
comedy_series <- comedy_movies_series %>%
  filter(type == "SHOW")
```


```{r}
netflix_popularity_by_year <- netflix %>%
  group_by(release_year) %>%
  summarise(avg_popularity = mean(na.omit(tmdb_popularity))) %>%
  filter(avg_popularity > 0)

hbo_popularity_by_year <- hbo %>%
  group_by(release_year) %>%
  summarise(avg_popularity = mean(na.omit(tmdb_popularity))) %>%
  filter(avg_popularity > 0)

amazon_popularity_by_year <- amazon %>%
  group_by(release_year) %>%
  summarise(avg_popularity = mean(na.omit(tmdb_popularity))) %>%
  filter(avg_popularity > 0)


```

Table {data-icon="fa-database"}
=====================================  


P1 {.tabset}
-------------------------------------

### Netflix

```{r}
netflix_menos <- netflix %>% select(-description)

datatable(netflix_menos, options=list(pageLength = 25, autoWidth = TRUE),
          style = "jqueryui", class = "table table-striped table-bordered",
          filter = 'top') %>%
  formatStyle(
    columns = c('id', 'title', 'type', 'release_year', 'age_certification', 'runtime', 'genres', 'production_countries', 'season', 'imdb_id', 'imdb_score', 'imdb_votes', 'tmdb_popularity', 'tmdb_score')
  )

```


### HBO


```{r}

hbo_menos <- hbo %>% select(-description)


datatable(hbo_menos, options=list(pageLength = 25, autoWidth = TRUE),
          style = "jqueryui", class = "table table-striped table-bordered",
          filter = 'top') %>%
  formatStyle(
    columns = c('id', 'title', 'type', 'release_year', 'age_certification', 'runtime', 'genres', 'production_countries', 'season', 'imdb_id', 'imdb_score', 'imdb_votes', 'tmdb_popularity', 'tmdb_score')
  )

```


### Amazon Prime

```{r}

amazon_menos <- amazon %>% select(-description)


datatable(amazon_menos, options=list(pageLength = 25, autoWidth = TRUE),
          style = "jqueryui", class = "table table-striped table-bordered",
          filter = 'top') %>%
  formatStyle(
    columns = c('id', 'title', 'type', 'release_year', 'age_certification', 'runtime', 'genres', 'production_countries', 'season', 'imdb_id', 'imdb_score', 'imdb_votes', 'tmdb_popularity', 'tmdb_score')
  )

```



Attribute analysis {data-icon="fa-bar-chart"}
=====================================  

Graficas {.tabset}
-------------------------------------


### Chart A
```{r}
renderPlotly({
  
p <- ggplot() +
  geom_line(data = netflix_popularity_by_year, aes(x = release_year, y = avg_popularity, color = "Netflix"), size = 1) +
  geom_line(data = hbo_popularity_by_year, aes(x = release_year, y = avg_popularity, color = "HBO"), size = 1) +
  geom_line(data = amazon_popularity_by_year, aes(x = release_year, y = avg_popularity, color = "Amazon Prime"), size = 1) +
  theme_minimal() +
  labs(title = "Distribución de la popularidad del contenido de cada plataforma por año", x = "Año", y = "Popularidad promedio", color = "Plataforma") +
  scale_x_continuous(breaks = seq(1900, 2025, 5), limits = c(1900, 2025)) +
  scale_color_manual(values = c("Netflix" = "#db1120", "HBO" = "#652bb9", "Amazon Prime" = "#1a98ff")) +
  theme(plot.title = element_text(size = 12, face = "bold", hjust = 0.5, vjust = 2))

ggplotly(p)
})
```

### Chart B

```{r}

renderHighchart({
 all_platforms %>%
  select(-id, -title, -type, -description, -release_year, -age_certification, -genres, -production_countries, -seasons, -imdb_id, -platform) %>%
  cor(use = 'complete.obs') %>%
  hchart() %>%
  hc_title(text = "Matriz de correlación", size = 12, face = "bold", hjust = 0.5, vjust = 2)
})

```   



```{r}
# Contar el número de títulos para cada género y plataforma, pero solo para los géneros comunes en los tres datasets
common_genres <- intersect(unique(hbo$genres), intersect(unique(amazon$genres), unique(netflix$genres)))

# Filtrar los datos para incluir solo los géneros comunes
filtered_data <- all_platforms %>%
  separate_rows(genres, sep = ", ") %>%
  filter(genres %in% common_genres) %>%
  group_by(platform, genres) %>%
  summarize(count = n())

# Calcular la media del número de títulos por género y plataforma
mean_data <- filtered_data %>%
  group_by(platform, genres) %>%
  summarize(mean_count = mean(count)) %>%
  ungroup()

# Ordenar los géneros por media del número de títulos descendente en Amazon Prime
amazon_data <- mean_data %>%
  filter(platform == "Amazon Prime") %>%
  mutate(genres = fct_reorder(genres, mean_count))

# Eliminar corchetes y comillas de los nombres de género
mean_data$genres <- str_replace_all(mean_data$genres, c("\\[|\\]" = "", "'" = ""))

# Eliminar la lista vacía
mean_data <- mean_data %>% filter(genres != "")

mean_data$genres <- factor(mean_data$genres, levels = mean_data$genres[order(mean_data$mean_count[mean_data$platform == "Amazon Prime"], decreasing = TRUE)])
```   



### Chart C
```{r}

renderPlotly({
  
generos <- ggplot(mean_data, aes(x = genres, y = mean_count, fill = platform)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = c("#1a98ff", "#652bb9", "#db1120")) +
  theme_minimal() +
  labs(title = "Top géneros por plataforma", x = "Género", y = "Número de títulos") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(plot.title = element_text(size = 12, face = "bold", hjust = 0.5, vjust = 2))

ggplotly(generos)
})

```

### Chart D
```{r}
top_movies <- comedy_movies %>% 
  arrange(desc(imdb_score)) %>% 
  slice(1:100)  # Filtrar las 100 películas con mayor puntuación

```


```{r}

renderPlotly({
ages <- top_movies %>% 
  ggplot( aes(x = age_certification, fill = platform)) +
  geom_bar(position = "dodge", width = 0.7) +  # Utiliza position = "dodge" y ajusta el ancho de las barras
  labs(title = "Películas exitosas por clasificación por edades y plataforma",
       x = "Clasificación por edades",
       y = "Cantidad de películas") +
  scale_fill_manual(values = c("Netflix" = "#db1120", "HBO" = "#652bb9", "Amazon Prime" = "#1a98ff")) + 
  theme(plot.title = element_text(size = 12, face = "bold", hjust = 0.5, vjust = 2))

ggplotly(ages)

})

```


### Chart E

```{r}
comedy_shows <- subset(all_shows, grepl("comedy", genres))

comedy_shows <- comedy_shows %>% 
  filter(age_certification != "")

top_series <- comedy_shows %>% 
  arrange(desc(imdb_score)) %>% 
  slice(1:100)  # Filtrar las 100 series con mayor puntuación 
```


```{r}
renderPlotly({
  ages_series <- top_series %>% ggplot(aes(x = age_certification, fill = platform)) +
  geom_bar(position = "dodge", width = 0.7) +  # Utiliza position = "dodge" y ajusta el ancho de las barras
  labs(title = "Series exitosas por clasificación por edades y plataforma",
       x = "Clasificación por edades",
       y = "Cantidad de series") +
  scale_fill_manual(values = c("Netflix" = "#db1120", "HBO" = "#652bb9", "Amazon Prime" = "#1a98ff")) +
  theme(plot.title = element_text(size = 12, face = "bold", hjust = 0.5, vjust = 2))

ggplotly(ages_series)
})
```

### Chart F

```{r}
comedy_movies <- subset(all_movies, grepl("comedy", genres))
comedy_movies <- comedy_movies %>% 
  filter(age_certification != "")

best_movies <- comedy_movies %>%
  arrange(desc(imdb_score)) %>%
  group_by(age_certification) %>%
  slice(1)

comedy_shows <- subset(all_shows, grepl("comedy", genres))
comedy_shows <- comedy_shows %>% 
  filter(age_certification != "")

best_series <- comedy_shows %>%
  arrange(desc(imdb_score)) %>%
  group_by(age_certification) %>%
  slice(1)

best_movies_and_series <- bind_rows(best_movies, best_series)
```


```{r}
renderPlotly({
  
  puntuacion <- best_movies_and_series %>% 
  ggplot(aes(x = imdb_score, y = title, fill = type)) +
  geom_bar(stat = "identity") +
  labs(title = "Puntuación de las mejores películas y series",
       x = "Puntuación",
       y = "Título") +
  theme_minimal() +
  theme(plot.title = element_text(size = 12, face = "bold", hjust = 0.5, vjust = 2),  # Ajusta las coordenadas del título
        axis.text = element_text(size = 9),
        legend.position = "top")  # Ajusta la posición de la leyenda

ggplotly(puntuacion)
})
```


### Chart G

```{r}
renderPlotly({
  
  # Crear el gráfico
grafico <- ggplot() +
  geom_line(data = netflix_popularity_by_year, aes(x = release_year, y = avg_popularity, color = "Netflix"), linetype = "solid") +
  geom_line(data = hbo_popularity_by_year, aes(x = release_year, y = avg_popularity, color = "HBO"), linetype = "solid") +
  geom_line(data = amazon_popularity_by_year, aes(x = release_year, y = avg_popularity, color = "Amazon Prime"), linetype = "solid") +
  scale_color_manual(values = c("Netflix" = "#db1120", "HBO" = "#652bb9", "Amazon Prime" = "#1a98ff")) +
  labs(title = "Popularidad por Año en Diferentes Plataformas", x = "Año", y = "Popularidad") +
  theme_minimal()

ggplotly(grafico)
})
```



### Chart H

```{r}
renderPlotly({

# Gráfico de comparación de duración de series por plataforma
time <- comedy_series %>%
  ggplot(aes(x = platform, y = runtime, fill = platform)) +
  geom_boxplot() +
  labs(title = "Comparación de duración de series por plataforma",
       x = "Plataforma",
       y = "Duración (minutos)",
       fill = "Plataforma") +
  scale_fill_manual(values = c("Netflix" = "#db1120", "HBO" = "#652bb9", "Amazon Prime" = "#1a98ff"))

ggplotly(time)

})
```

### Chart I

```{r}
renderPlotly({
  
  # Gráfico de comparación de duración de películas por plataforma
time <- comedy_movies %>%
  ggplot(aes(x = platform, y = runtime, fill = platform)) +
  geom_boxplot() +
  labs(title = "Comparación de duración de películas por plataforma",
       x = "Plataforma",
       y = "Duración (minutos)",
       fill = "Plataforma") +
  scale_fill_manual(values = c("Netflix" = "#db1120", "HBO" = "#652bb9", "Amazon Prime" = "#1a98ff"))

ggplotly(time)

})
```

### Chart J

```{r}
# Filtrar películas de comedia
comedy_series <- subset(all_shows, grepl("comedy", genres))

comedy_series_for_each_initial <- comedy_series %>%
  mutate(production_countries = str_remove_all(production_countries, "\\[|\\]")) %>%
  separate_rows(production_countries, sep = ",\\s*") %>%
  mutate(production_countries = str_remove_all(production_countries, "'\\s*"))

# Crear un DataFrame de mapeo entre iniciales y nombres completos
mapeo <- data.frame(production_countries = c("EG", "BE", "ES", "Lebanon", "KW", "MY", "CL", "SG", "IL", "AE", "IS", "UA", "JP", "PH", "GE", "PE", "NO", "PS", "GH", "TZ", "", "TN", "FI", "NP", "TW", "BD", "GB", "CA", "LK", "NG", "DK", "CM", "ID", "TH", "TR", "SE", "SY", "PL", "GR", "AT", "QA", "CH", "PT", "JO", "AF", "LU", "SA", "IO", "FO", "SU", "CZ", "MX", "GT", "NZ", "BR", "CO", "US", "RU", "CY", "IT", "BO", "NL", "VE", "DO", "YU", "LI", "FR", "AN", "LT", "IE", "HU", "HK", "KZ", "ZA", "CN", "FJ", "UG", "KR", "RS", "AR", "MA", "XX", "AQ", "VN", "IR", "PA", "AL", "LB", "PR", "MN", "SK", "IN", "AU", "CU", "DE", "UY", "LY", "AO", "BA", "BG", "CI", "CR", "EE", "ET", "GL", "KE", "KH", "LV", "MC", "MU", "PK", "RO", "PY", "SI", "SZ", "United States of America", "ZW"),
                      Country = c("Egypt", "Belgium", "Spain", "Lebanon", "Kuwait", "Malaysia", "Chile", "Singapore", "Israel", "United Arab Emirates", "Iceland", "Ukraine", "Japan", "Philippines", "Georgia", "Peru", "Norway", "Palestine", "Ghana", "Tanzania", "", "Tunisia", "Finland", "Nepal", "Taiwan", "Bangladesh", "United Kingdom", "Canada", "Sri Lanka", "Nigeria", "Denmark", "Cameroon", "Indonesia", "Thailand", "Turkey", "Sweden", "Syria", "Poland", "Greece", "Austria", "Qatar", "Switzerland", "Portugal", "Jordan", "Afghanistan", "Luxembourg", "Saudi Arabia", "British Indian Ocean Territory", "Faroe Islands", "Soviet Union (no longer exists)", "Czech Republic", "Mexico", "Guatemala", "New Zealand", "Brazil", "Colombia", "United States", "Russia", "Cyprus", "Italy", "Bolivia", "Netherlands", "Venezuela", "Dominican Republic", "Yugoslavia (no longer exists)", "Liechtenstein", "France", "Netherlands Antilles (no longer exists)", "Lithuania", "Ireland", "Hungary", "Hong Kong", "Kazakhstan", "South Africa", "China", "Fiji", "Uganda", "South Korea", "Serbia", "Argentina", "Morocco", "Unknown country", "Antarctica", "Vietnam", "Iran", "Panama", "Albania", "Lebanon", "Puerto Rico", "Mongolia", "Slovakia", "India", "Australia", "Cuba", "Germany", "Uruguay", "Libya", "Angola", "Bosnia", "Bulgaria", "Côte d'Ivoire", "Costa Rica", "Estonia", "Ethiopia", "Greenland", "Kenya", "Cambodia", "Latvia", "Monaco", "Mauritius", "Pakistan", "Romania", "Paraguay", "Slovenia", "Eswatini", "United States", "Zimbabwe"))

# Realizar el merge para obtener los nombres completos
comedy_series_for_each_country <- merge(comedy_series_for_each_initial, mapeo, by = "production_countries", all.x = TRUE)

# Crear un nuevo dataframe sin filas que tengan NA en la columna "temperatura"
comedy_series_for_each_country <- comedy_series_for_each_country[!is.na(comedy_series_for_each_country$Country), ]
paleta_colores <- rainbow(1000)
```


```{r}
renderPlotly({
  
  fig <- plot_ly(comedy_series_for_each_country, 
               x = ~imdb_score, 
               y = ~tmdb_score, 
               text = ~paste("Título:", title, "<br>", "Año:", release_year, "<br>", "Plataforma:", platform), 
               frame = ~Country, 
               hoverinfo = "text",
               type = "scatter", 
               mode = "markers", 
               marker = list(size = 10, color = paleta_colores))

fig <- fig %>% layout(
  title = "<b>Relación entre valoración de series y el país de producción.<b>",
  xaxis = list(title = "IMDb Score"),
  yaxis = list(title = "TMDB Score"),
  hoverlabel = list(bgcolor = "white"),
  hovermode = "closest",
  showlegend = F
)

fig

})
```



```{r}
renderPlotly({})
```



World Map {data-icon="fa-map-marker"}
=====================================  
    
    
Column {.sidebar data-width=240}
--------------------------------------------------


```{r}

# Función para cargar y limpiar datos de cada plataforma
data <- function(platform) {
  # Carga y limpieza de datos
  df_clean <- platform %>%
    mutate(production_countries = gsub("\\[|\\]|'| ", "", production_countries))
  
  # Separar las múltiples abreviaturas de países en filas individuales
  df_split <- df_clean %>%
    mutate(production_countries = strsplit(production_countries, ",")) %>%
    unnest(production_countries)
  
  # Crear un dataframe para almacenar los resultados
  results <- data.frame(
    production_countries = character(),
    mean_imdb_score = numeric(),
    mean_imdb_votes = numeric(),
    mean_tmdb_popularity = numeric(),
    stringsAsFactors = FALSE
  )
  
  # Obtener la lista de países únicos
  countries <- unique(df_split$production_countries)
  
  # Iterar sobre cada país
  for (country in countries) {
    # Filtrar el dataframe para el país actual
    df_country <- df_split[df_split$production_countries == country, ]
    
    # Calcular las métricas
    mean_imdb_score <- mean(df_country$imdb_score, na.rm = TRUE)
    mean_imdb_votes <- mean(df_country$imdb_votes, na.rm = TRUE)
    mean_tmdb_popularity <- mean(df_country$tmdb_popularity, na.rm = TRUE)
    
    # Agregar los resultados al dataframe
    results <- rbind(results, data.frame(
      production_countries = country,
      mean_imdb_score = mean_imdb_score,
      mean_imdb_votes = mean_imdb_votes,
      mean_tmdb_popularity = mean_tmdb_popularity
    ))
  }
  
  
  correspondencias <- c(
  "AE" = "ARE",
  "AF" = "AFG",
  "AL" = "ALB",
  "AM" = "ARM",
  "AN" = "ANT",
  "AO" = "AGO",
  "AR" = "ARG",
  "AT" = "AUT",
  "AU" = "AUS",
  "BA" = "BIH",
  "BD" = "BGD",
  "BE" = "BEL",
  "BF" = "BFA",
  "BG" = "BGR",
  "BM" = "BMU",
  "BO" = "BOL",
  "BR" = "BRA",
  "BS" = "BHS",
  "BT" = "BTN",
  "BY" = "BLR",
  "CA" = "CAN",
  "CD" = "COD",
  "CF" = "CAF",
  "CG" = "COG",
  "CH" = "CHE",
  "CI" = "CIV",
  "CL" = "CHL",
  "CM" = "CMR",
  "CN" = "CHN",
  "CO" = "COL",
  "CR" = "CRI",
  "CU" = "CUB",
  "CV" = "CPV",
  "CY" = "CYP",
  "CZ" = "CZE",
  "DE" = "DEU",
  "DJ" = "DJI",
  "DK" = "DNK",
  "DO" = "DOM",
  "DZ" = "DZA",
  "EC" = "ECU",
  "EE" = "EST",
  "EG" = "EGY",
  "EH" = "ESH",
  "ER" = "ERI",
  "ES" = "ESP",
  "ET" = "ETH",
  "FI" = "FIN",
  "FJ" = "FJI",
  "FK" = "FLK",
  "FO" = "FRO",
  "FR" = "FRA",
  "GA" = "GAB",
  "GB" = "GBR",
  "GD" = "GRD",
  "GE" = "GEO",
  "GF" = "GUF",
  "GH" = "GHA",
  "GL" = "GRL",
  "GM" = "GMB",
  "GN" = "GIN",
  "GP" = "GLP",
  "GQ" = "GNQ",
  "GR" = "GRC",
  "GT" = "GTM",
  "GU" = "GUM",
  "GW" = "GNB",
  "GY" = "GUY",
  "HK" = "HKG",
  "HN" = "HND",
  "HR" = "HRV",
  "HT" = "HTI",
  "HU" = "HUN",
  "ID" = "IDN",
  "IE" = "IRL",
  "IL" = "ISR",
  "IN" = "IND",
  "IO" = "IOT",
  "IQ" = "IRQ",
  "IR" = "IRN",
  "IS" = "ISL",
  "IT" = "ITA",
  "JM" = "JAM",
  "JO" = "JOR",
  "JP" = "JPN",
  "KE" = "KEN",
  "KG" = "KGZ",
  "KH" = "KHM",
  "KI" = "KIR",
  "KM" = "COM",
  "KN" = "KNA",
  "KP" = "PRK",
  "KR" = "KOR",
  "KW" = "KWT",
  "KY" = "CYM",
  "KZ" = "KAZ",
  "LA" = "LAO",
  "LB" = "LBN",
  "LC" = "LCA",
  "LI" = "LIE",
  "LK" = "LKA",
  "LR" = "LBR",
  "LS" = "LSO",
  "LT" = "LTU",
  "LU" = "LUX",
  "LV" = "LVA",
  "LY" = "LBY",
  "MA" = "MAR",
  "MC" = "MCO",
  "MD" = "MDA",
  "ME" = "MNE",
  "MG" = "MDG",
  "MH" = "MHL",
  "MK" = "MKD",
  "ML" = "MLI",
  "MM" = "MMR",
  "MN" = "MNG",
  "MO" = "MAC",
  "MP" = "MNP",
  "MQ" = "MTQ",
  "MR" = "MRT",
  "MS" = "MSR",
  "MT" = "MLT",
  "MU" = "MUS",
  "MV" = "MDV",
  "MW" = "MWI",
  "MX" = "MEX",
  "MY" = "MYS",
  "MZ" = "MOZ",
  "NA" = "NAM",
  "NC" = "NCL",
  "NE" = "NER",
  "NF" = "NFK",
  "NG" = "NGA",
  "NI" = "NIC",
  "NL" = "NLD",
  "NO" = "NOR",
  "NP" = "NPL",
  "NR" = "NRU",
  "NU" = "NIU",
  "NZ" = "NZL",
  "OM" = "OMN",
  "PA" = "PAN",
  "PE" = "PER",
  "PF" = "PYF",
  "PG" = "PNG",
  "PH" = "PHL",
  "PK" = "PAK",
  "PL" = "POL",
  "PM" = "SPM",
  "PN" = "PCN",
  "PR" = "PRI",
  "PS" = "PSE",
  "PT" = "PRT",
  "PW" = "PLW",
  "PY" = "PRY",
  "QA" = "QAT",
  "RE" = "REU",
  "RO" = "ROU",
  "RS" = "SRB",
  "RU" = "RUS",
  "RW" = "RWA",
  "SA" = "SAU",
  "SB" = "SLB",
  "SC" = "SYC",
  "SD" = "SDN",
  "SE" = "SWE",
  "SG" = "SGP",
  "SH" = "SHN",
  "SI" = "SVN",
  "SJ" = "SJM",
  "SK" = "SVK",
  "SL" = "SLE",
  "SM" = "SMR",
  "SN" = "SEN",
  "SO" = "SOM",
  "SR" = "SUR",
  "ST" = "STP",
  "SV" = "SLV",
  "SY" = "SYR",
  "SZ" = "SWZ",
  "TC" = "TCA",
  "TD" = "TCD",
  "TF" = "ATF",
  "TG" = "TGO",
  "TH" = "THA",
  "TJ" = "TJK",
  "TK" = "TKL",
  "TL" = "TLS",
  "TM" = "TKM",
  "TN" = "TUN",
  "TO" = "TON",
  "TR" = "TUR",
  "TT" = "TTO",
  "TV" = "TUV",
  "TW" = "TWN",
  "TZ" = "TZA",
  "UA" = "UKR",
  "UG" = "UGA",
  "US" = "USA",
  "UY" = "URY",
  "UZ" = "UZB",
  "VA" = "VAT",
  "VC" = "VCT",
  "VE" = "VEN",
  "VG" = "VGB",
  "VI" = "VIR",
  "VN" = "VNM",
  "VU" = "VUT",
  "WF" = "WLF",
  "WS" = "WSM",
  "YE" = "YEM",
  "YT" = "MYT",
  "ZA" = "ZAF",
  "ZM" = "ZMB",
  "ZW" = "ZWE"
)

  
  # Mapeo de abreviaturas de países
  results$production_countries <- correspondencias[results$production_countries]
  
    # Carga de datos geojson
  geoj <- geojson_read("https://ctim.es/AEDV/data/geo_countries.geojson", what="sp")
  
  # Convertir a tibble
  geoj.tibble <- geoj %>% 
    as_tibble()
  
  # Unión de datos
  join_data <- left_join(geoj.tibble, results, by = c("ISO_A3" = "production_countries"))
  
  return(join_data)
}

  

# Llamadas a las funciones para cada plataforma

join_netflix <- data(netflix)
join_hbo <- data(hbo)
join_amazon <- data(amazon)

get_data <- function(platform) {
  switch(platform,
         "Netflix" = join_netflix,
         "HBO" = join_hbo,
         "Amazon Prime" = join_amazon)
}


```



```{r}
# Selector de plataforma de streaming
selectInput(
  "platform", 
  label = "Plataforma:",
  choices = c("Netflix", "HBO", "Amazon Prime"), 
  selected = "Netflix"
)

# Selector de indicador
output$select_indicator <- renderUI({
  platform <- input$platform
  choices <- switch(platform,
                    "Netflix" = colnames(join_netflix)[(3:5)],
                    "HBO" = colnames(join_hbo)[(3:5)],
                    "Amazon Prime" = colnames(join_amazon)[(3:5)])
  selectInput("indicator", 
              label = "Indicator:",
              choices = choices, 
              selected = choices[1])
})

uiOutput("select_indicator")


```

### 


```{r}
renderTable({
  data <- get_data(input$platform)[[which(names(get_data(input$platform))==input$indicator)]]
  tibble( 
    country=get_data(input$platform)$ADMIN,
    value=round(data,digits=2)
  ) %>%
    filter(is.na(value)==FALSE) %>%
    arrange(desc(value)) %>%
    mutate(value=prettyNum(round(value,digits=2))) %>%
    head(300)
})

#distinct(country, .keep_all = TRUE) %>%  # Añade esta línea para eliminar filas duplicadas por país


```
   
Column
-------------------------------------
   
### 

```{r}

leaflet::renderLeaflet({

  indicator_column <- which(names(get_data(input$platform)) == input$indicator)
  
    data <- get_data(input$platform)[[indicator_column]]
    map_data <- data.frame(country = get_data(input$platform)$ADMIN, data)

  pal <- leaflet::colorQuantile("YlOrRd", data, n = 9)
  etiquetas <- ~paste("<strong> ", ADMIN ,"</strong><br>",input$indicator,": ",prettyNum(round(data,digits=2), big.mark = ",", scientific = FALSE))  %>%
  lapply(htmltools::HTML)
  
  geojson <- geojson_read("https://ctim.es/AEDV/data/geo_countries.geojson", what = "sp")
  
  leaflet() %>%  
    addTiles() %>%
    setView(lng = 25, lat = 22, zoom = 2) %>% 
    addPolygons(data = geojson,
                fillColor = ~pal(data), 
                weight = 2,
                opacity = 1,
                color = "white",
                dashArray = "3",
                fillOpacity = 0.7,
                highlightOptions = highlightOptions( 
                  weight = 2,
                  color = rgb(0.2,0.2,0.2),
                  dashArray = "",
                  fillOpacity = 0.7,
                  bringToFront = TRUE
                ),
                label =etiquetas) %>%
    addControl(input$indicator, position = "topright") %>% 
    addLegend("topright", pal = pal, values = map_data$data,
              title = " ",
              labFormat = function(type, cuts, p) {
                n = length(cuts) 
                x = (cuts[-n] + cuts[-1])/2
                x = prettyNum(round(x, digits = 2), big.mark = ",", scientific = FALSE)
                as.character(x)
              },
              opacity = 1)
})


```
